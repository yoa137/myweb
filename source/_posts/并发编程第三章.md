

---
title: GPSapp
date: 2025-10-27 22:00:00
tags: [多线程,c++]	
categories: 实践
label: "hhhhh"
description: 并发编程第三章 线程间共享数据

---
## 代码列表

- std::lock示例
- 死锁示例
- 层级互斥示例
- callonce示例
## 问题发生

不变量被破坏，条件竞争（race condition）

### 条件竞争
并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。

### 避免恶性条件竞争

- 数据结构的保护，锁

- 无锁编程lock-free 

- 事务方式STM

## 互斥保护共享数据

### 互斥



``` cpp
#include <mutex>
#include <algorithm>
#include <list>

std::list<int> some_list;
std::mutex some_mutex;
void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex); //RALL风格的互斥
    std::lock_guard guard(some_mutex);  //C++17类模版参数推导
    std::scoped_lock guard(some_mutex); //加强版lock_guard，可变参数模版
    some_list.push_back(new_value);
}
bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    return std::find(some_list.begin(), some_list.end(), value_to_find) != some_list.end();
}

```
tips:
- 互斥与受保护的数据组成一个类
- 成员函数返回指针或者引用，则互斥出现漏洞

### 组织和编排代码以保护共享数据
除了指针或引用，成员函数在自身调用别的函数也可能导致危险

### 发现接口固有的条件竞争
栈的pop和top潜在的条件竞争，empty和top潜在的条件竞争，同时pop会出现异常安全的情况，pop复制弹出的变量时，若内存空间不足，会引发异常导致数据消失。

锁的粒度太小，没办法覆盖所有操作。

需要设计线程安全和异常安全的栈
- 传入引用，用引用去取数据
- 提供不抛出异常的拷贝构造函数或移动构造函数 型别判断
``` cpp
std::is_nothrow_copy_constructible
和 std::is_nothrow_move_constructible 
```
- 返回指针，智能指针
- 简化stack接口，pop，push，empty

### 死锁：问题和解决方法
有两个线程同时要锁住两个互斥

``` cpp 
// [多线程安全的swap函数]
class some_big_object;
void swap(some_big_object& lhs, some_big_object& rhs);
class X 
{
private:
    some_big_object some_detail;
    std::mutex mutex;
public:
    X(some_big_object const& sd) : some_detail(sd) {}
    friend void swap(X& lhs, X& rhs)
    {
        if (&lhs == &rhs) return;
        std::lock(lhs.m, rhs.m);
        std::lock_guard<std::mutex> lhs_lock(lhs.m, std::adopt_lock);
        std::lock_guard<std::mutex> rhs_lock(rhs.m, std::adopt_lock);
        swap(lhs.some_detail, rhs.some_detail);
    }

};
````
解决方法：
- std::lock()同时锁住多个互斥锁 allornothin，一损俱损
- std::scoped_lcok<std::mutex, std::mutex> c++17
### 防范死锁的补充准则
当代码分别获取各个锁，这两个函数就没做作用了

tips:
- 两个线程互相join也会出现死锁
- 只要一个线程有可能正在等待当前线程，当前线程不能反过来等待它
死锁避免准则
- 避免嵌套锁，一个线程只有一个锁
- 一旦有锁，应该避免调用由用户提供的程序接口
- 依从固定顺序获取锁，链表按顺序遍历
- 按层级加锁，按特定方式规定加锁次序
``` cpp
//层级互斥
//hierarchical_mutex 类 lock, unlock, try_lock
```
- 将准则推广到锁操作以外，层级线程

### std::unique_lock 灵活加锁
- unique_lock会有性能损失，占用更大存储空间（标志位），以提高灵活性。
- 可以在销毁前解锁，提高性能
```cpp
std::defer_lock //将互斥保留为无锁状态
std::unique_lock<std::mutex> ulock(data,std::defer_lock)
ulock.owns_lock() // 是否获取锁
std::lock(ulock)
```
### 在不同作用域转移互斥归属权
使用unique_lock

归宿权转移的情况:
- 互斥加锁的时机取决于程序的当前状态
- 某函数负责执行加锁，时机由传入的参数决定

例子:
- gateway类，数据通过gateway类才能访问


### 按适合的粒度加锁
tip: 
- 超市排队例子，等东西拿齐了再去结账
- 持锁期间应该避免耗时操作

## 保护共享数据的其他工具

### 初始化过程中保护共享数据
- 延迟初始化，浪费时间的方式
```cpp
std::shared_ptr<some_resource> resource_ptr;
std::mutex resource_mutex;
void access_resource() {
    std::unique_lock<std::mutex> lock(resource_mutex);
    if (!resource_ptr) {
        resource_ptr = std::make_shared<some_resource>();
    }
    lock.unlock();
    resource_ptr->do_something();
    
}
```
- 双重检验方式，会导致恶性条件竞争
```cpp
void access_resource() {
    std::shared_ptr<some_resource> temp_ptr;
    if (!resource_ptr) {
        std::lock_guard<std::mutex> lock(resource_mutex);
        if (!resource_ptr) {
            resource_ptr = std::make_shared<some_resource>();
        }
        temp_ptr = resource_ptr;
        lock.unlock();
    }

    temp_ptr->do_something();
}

```
- std::call_once()

- c++11的线程安全静态数据

### 保护很少更新的数据结构
tips:
- 在写操作很少的系统上可以用，提高性能
- 为了看用了读写锁后的性能提升，需要进行性能剖析
方法:
- 共享锁C++17两种，C++14一种，C++11无
- 同步操作，多个线程可以锁住一个共享锁，这时其他线程不能获得排他锁。

### 递归加锁
std::recursive_mutex，锁几次就要释放几次
- 当觉得要用到递归锁的时候，得重新审视代码结构是否合理


