

---
title: GPSapp
date: 2025-10-27 22:00:00
tags: [多线程,c++]	
categories: 实践
label: "hhhhh"
description: 并发编程第二章 线程管理

---
## 代码列表
- 启动线程方法
- detach释放资源示例
- 引用错误示例
## 线程管理基础

### 启动线程

线程启动方式

- 使用函数对象，注意临时变量解析问题
``` cpp
//会被解析为函数定义
std::thread my_thread(background_task());
//正确方法
std::thread my_thread((background_task())); // 1
std::thread my_thread{background_task()}; // 2

```
- 使用函数
- 使用lambda表达式（C++11）
- 类成员函数
``` cpp
class X
{
public:
void do_lengthy_work(int);
};
X my_x;
int num(0);
std::thread t(&X::do_lengthy_work, &my_x, num);
```

tips：
- 要在线程销毁前决定分离还是等待
- 最好用复制的变量而不是引用的变量，防止变量被销毁后访问

### 等待线程完成
``` cpp
thread.join();
```

tips:
- 粗暴的等待停止，调用后会清除线程相关的存储部分，对一个线程只能使用一次
``` cpp
thread.joinable(); //false
```
- 使用join要避免异常情况发生时正常处理，异常安全(exception-safety)问题

``` cpp
//方式一
struct func; // 定义在清单2.1中
void f()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread t(my_func);
    try
    {
        do_something_in_current_thread();
    }
    catch (...)
    {
        t. join();  //1
        throw;
    }
    t. join(); // 2
}
//方式二 RALL方式
#include <thread>

class thread_guard {
    std::thread& t;
public:
    explicit thread_guard(std::thread& t_) : t(t_) {}
    ~thread_guard() {
        if (t.joinable()) {
            t.join();
        }
    }
    thread_guard(thread_guard const&) = delete;
    thread_guard& operator=(thread_guard const&) = delete;
};

// 假设 struct func 在清单 2.1 中定义，例如：
struct func {
    int& i;
    func(int& i_) : i(i_) {}
    void operator()() {
        // 做一些工作...
        for (int k = 0; k < 3; ++k) {
            // 模拟工作
            ++i;
        }
    }
};

void do_something_in_current_thread() {
    // 当前线程做点事情的占位函数
}

void f() {
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
} // 在这里 thread_guard 的析构函数会确保 t 被 join
```



### 后台运行线程

``` cpp
    thread.detach()
```
使用场景
- 守护线程（daemon threads），没有用户接口且在后台运行的线程，长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。
- "发后即忘"(fire and forget)的任务

tips:
- 分离后，没有thread对象引用到他
``` cpp
std::thread t(do_background_work);
t.detach();
assert(!t.joinable());
```


## 传递参数
- 使用可调用对象传递
- 使用thread参数传递


tips:
- 使用thread参数传递默认为复制传递，实际传递的是内部变量的引用
``` cpp
// 假设这些类型在其他地方已定义：
using widget_id = int;
struct widget_data {
    // ...
};

// 声明：更新 widget 的函数
void update_data_for_widget(widget_id w, widget_data& data);

// 使用的函数体
void oops_again(widget_id w)
{
    widget_data data;
    // 注意：update_data_for_widget 接受 widget_data& （非 const 引用）
    // 因此需要通过 std::ref 将 data 以引用传递给线程
    std::thread t(update_data_for_widget, w, data);//实际传递的是内部变量的引用
    display_status();
    t.join();
    process_widget_data(data);
}

//解决方法
std::thread t(update_datafor_widget,w,std::ref(data));//转换成引用

```
- 智能指针参数的传递

``` cpp
    std::unique_ptr<big_object> p(new big_object);
    p->prepare_data(42);

    // 将所有权移动到线程函数中：必须使用 std::move
    std::thread t(process_big_object, std::move(p));

    // 等待线程完成（或 detach，根据需要）
    t.join();

```

## 转移线程所有权
使用原因：
- 要使用一个函数返回值线程
- 


tips：
- 临时对象移动会隐式调用
- 不能进行赋值操作
``` cpp
std::thread t1(some_function);            // 1: t1 启动 some_function
std::thread t2 = std::move(t1);          // 2: 将 t1 的线程句柄移动到 t2（t1 变为未关联状态）
t1 = std::thread(some_other_function);   // 3: 重新给 t1 赋一个新线程
std::thread t3;                          // 4: 默认构造：t3 是未关联的（not joinable）
t3 = std::move(t2);                      // 5: 将 t2 的线程句柄移动到 t3（t2 变为未关联）
t1 = std::move(t3);                      // 6: 赋值操作会使程序崩溃（如果违反了 std::thread 的规则）s
```


## 决定线程数量
量产线程
```cpp
void do_work(unsigned id);
void f()
{
    std::vector<std::thread> threads;
    for(unsigned i=0; i < 20; ++i)
    {
        threads.push_back(std::thread(do_work,i)); // 产生线程
    }
    std::for_each(threads.begin(),threads.end(),std::mem_fn(&std::thread::join)); // 对每个线程调用join()
}
std::thread::hardware_concurrency(). //最大可并发线程数量
```

## 识别线程

``` cpp
std::thread::id  //没有线程返回std::thread::type默认值
std::this_thread::get_id() //当前线程
```


## 任务
实现accumulate的并行版本。