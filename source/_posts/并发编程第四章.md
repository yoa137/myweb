

---
title: c++并发编程
date: 2025-11-10 22:00:00
tags: [多线程,c++]	
categories: 实践
label: "hhhhh"
description: 并发编程第四章 并发同步

---
## 代码列表

- std::lock示例
- 死锁示例
- 层级互斥示例
- callonce示例
## 等待事件或其他条件
等一个线程需要等待另一个线程时
- 忙等待，设置标志位，浪费计算资源
- std::this_thread::sleep_for()函数，休眠时间会过长或过短
- 唤醒，条件变量等工具
### 条件变量
std::condition_variable 和 std::condition_variable_any
- std::condition_variable 只能与std::mutex配合使用
- std::condition_variable_any更加通用，但有额外开销
``` cpp
//wait
std::mutex mut;
std::queue<some_data> data_queue;
std::condition_variable data_cond;
void data_preparation_thread()
{
    while (more_data_to_prepare())
    {
        some_data data = prepare_data();
        {
            std::lock_guard<std::mutex> lk(mut);
            data_queue.push(data);
        }
        data_cond.notify_one();
    }
}
some_data data_processing_thread()
{
    while (true)
    {
        std::unique_lock<std::mutex> lk(mut);
        data_cond.wait(lk, [] { return !data_queue.empty(); });
        some_data data = data_queue.front();
        data_queue.pop();
        lk.unlock();
        process(data);
    }
}

```

tips:
- wait函数调用期间，条件变量可以多次查验给定的条件，这涉及到伪唤醒(spurious wake)，不是响应通知的唤醒，如果判定有副作用，可能会产生意想不到的行为。
- wait本质上是忙等待的优化

### 线程安全的队列

- wait_and_pop, try_pop
- front,back都不要

## futrue等待一次性事件发生
独占future和共享future